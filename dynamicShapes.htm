<html>
<head>
<title>loEngine</title>
<script src="loEngine.src.js"></script>
<script type="application/javascript">

/*
	TODO	
		Test custom shapes - ones not created with loMakeNArray()
*/

// Various shapes to test

// Confine cube within a circle of radius 50
var cube	= loCreateHexagon( 300, 100, loConfine( 50 ) );
// Unconfined rectangle (circle radius is not important)
var rect	= loCreateRect( 100, 100, 50, 25 );
var tri		= loCreateTri( 100, 300, loConfine( 50 ) );
// Standard method of creating a polygon of n-sides
var npoly	= loPolygon.create( 300, 300, loConfine( 50 ), loMakeNArray( 4 ) )


var randomly = []

// Light source placeholder
var circle	= loCircle.create( 200, 200, 50 )

// Circular shadow caster test
var circle2	= loCircle.create( 300, 214, 20 )

// REAL fumbling mess of tests
function keydownControl(e)
{
	var ang = 0;
	
	if( e.keyCode == 39 )
		ang += 2;
	else
	if( e.keyCode == 37 )
		ang -= 2;
	
	var c = false;
	
	if( e.keyCode == 83 )
	{
		npoly.y += 10;
		circle2.x += 10
		c = true
	}
	else if( e.keyCode == 84 )
	{
		circle2.x -= 10
		c = true
	}
	
	if( e.keyCode == 188 )
	{
		rect.width += 1
		rect.height += 1
		rect.doResize()
		c = true
	}else if( e.keyCode == 190 )
	{
		rect.width -= 1
		rect.height -= 1
		rect.doResize()
		c = true
	}
	
	if( !( ang == 0 && c == false ) )
	{
		var arr = [cube,rect,tri,npoly]
		
		if( randomly.length > 0 ) arr = arr.concat( randomly )
		
		var i = 0;
		while(i<arr.length)
		{
			arr[i].rotate( arr[i].angle+ang );
			++i
		}
		
		/*
		cube.rotate( cube.angle + ang );
		rect.rotate( rect.angle + ang );
		tri.rotate( tri.angle + ang );
		npoly.rotate( npoly.angle + ang );
		*/
		draw();
	}
}

function draw() {
	var canvas = document.getElementById("canvas");
	var ctx = canvas.getContext("2d");
	
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	ctx.fillStyle = "#000";
	// draw black background
	/*
	ctx.fillRect( 0, 0, canvas.width, canvas.height)
	*/

	// Project points from vertices
	var arr = [cube,rect,tri,npoly]
	//arr = arr.concat( randomly )
	
	//arr = [rect]
	var i = 0;
	var srcCenter = loAsPoint( circle )

	/*
	var grd = ctx.createRadialGradient(
		srcCenter.x,
		srcCenter.y,
		1,
		srcCenter.x,
		srcCenter.y,
		circle.radius
	);
	
	grd.addColorStop(0, "rgb(255,255,255)");
	// dark blue
	grd.addColorStop(1, "#000000");
	
	ctx.beginPath();
	ctx.arc(
		srcCenter.x,
		srcCenter.y,
		circle.radius,
		0,
		2*Math.PI,
		false
	)
	
	ctx.fillStyle = grd;
	ctx.fill();
	*/
	
	ctx.strokeStyle = "#000";
	
	
	


	
	while( i < arr.length )
	{
		var plyCenter = loAsPoint( arr[i] )
		
		var ps = []
		
		var j = 0;
		while( j < arr[i].sides )
		{
			// Find the midpoint on the edge
			var mp = arr[i].midat( j )
			
			// Make vector from shape center to midpoint
			var v1 = loMakeVec2( plyCenter, mp )
			
			// Make vector from light source to midpoint
			var v2 = loMakeVec2( srcCenter, mp )

			// If the angle between these two vectors is less than 90deg
			if( v1.angle( v2 ) < 90 )
				// Add to a list of points which cast a shadow
				ps.push( j )
			
			++j
		}
		
		
		/*
			An attempt to draw the entire shadow as point polygon using lineTo
			
			It can be done, but my code doesn't quite work
		*/
		
		/*
		if( ps.length == 1 )
		{
		
		}
		else
		{
			var p1 = arr[i].at( ps[ 0 ] )
			var v1 = loMakeVec2( srcCenter, p1 )
			v1.normalize( 300 )
			var p1e = p1.add( loPoint.create( v1.i, v1.j ) )
			
			ctx.fillStyle = "rgba(0,0,0,0.4)"
			ctx.strokeStyle = "rgba(0,0,0,1)"
			
			ctx.beginPath()
			ctx.moveTo( p1.x, p1.y );
			ctx.lineTo( p1e.x, p1e.y );
			
			j = 1
			while( j < ps.length )
			{
				var p2 = arr[i].at( ps[ j ]+1 )
				var v2 = loMakeVec2( srcCenter, p2 )
				v2.normalize( 300 )
				var p2e = p2.add( loPoint.create( v2.i, v2.j ) )
				
				ctx.lineTo( p2e.x, p2e.y )
				++j
			}
			
			
			ctx.lineTo( p2.x, p2.y )
			ctx.lineTo( p1.x, p1.y )
			ctx.fill()
			ctx.stroke()

		}
		*/
		j = 0;
		while( j < ps.length )
		{
			var p1 = arr[i].at( ps[ j ] )
			var v1 = loMakeVec2( srcCenter, p1 )
			v1.normalize( 300 )
			var p1e = p1.add( loPoint.create( v1.i, v1.j ) )
			
			var p2 = arr[i].at( ps[ j ]+1 )
			var v2 = loMakeVec2( srcCenter, p2 )
			v2.normalize( 300 )
			var p2e = p2.add( loPoint.create( v2.i, v2.j ) )

			ctx.fillStyle = "rgba(0,0,0,1)"
			ctx.strokeStyle = "rgba(0,0,0,0)"
			
			ctx.beginPath()
			ctx.moveTo( p1e.x, p1e.y );
			ctx.lineTo( p1.x, p1.y );
			ctx.lineTo( p2.x, p2.y );
			ctx.lineTo( p2e.x, p2e.y );
			ctx.moveTo( p1e.x, p1e.y );
			
			ctx.fill();
			ctx.stroke()
		
			++j
		}
		
		
		++i
	}
	
	// Draw each object - NOTE: debug drawings are not styled as requested
	
	i = 0;
	while( i < arr.length )
	{
		loDrawDebug( ctx, arr[i] )
		++i
	}
	
	loDrawDebug( ctx, circle,	"rgba(50,50,200,0.4)" );
	
	var sh = circle2.shadowing( srcCenter )
	
	if( sh.length == 4 ) // else, it is empty
	{
		var p1 = sh[0].add( circle2 )
		var p2 = sh[1].add( circle2 )

		ctx.fillStyle = "rgb(0,0,0)"
		ctx.strokeStyle = "rgb(200,0,0)"
		
		ctx.beginPath()
//		ctx.moveTo( srcCenter.x, srcCenter.y )
		ctx.moveTo( p1.x, p1.y )
		
		var v2 = loMakeVec2( srcCenter, p1 )
		v2.normalize( 300 )
		var p1e = p1.add( loPoint.create( v2.i, v2.j ) )
		ctx.lineTo( p1e.x, p1e.y )
		
//		ctx.stroke()
		//ctx.beginPath()
		
		//ctx.stroke()

		//ctx.beginPath()
		//ctx.arc( circle2.x, circle2.y, 300, loAsRad( sh[2] ), loAsRad( sh[3] ), true );
		//ctx.stroke()
		
		//ctx.beginPath()
		
		var v2 = loMakeVec2( srcCenter, p2 )
		v2.normalize( 300 )
		var p2e = p2.add( loPoint.create( v2.i, v2.j ) )
		//ctx.moveTo( p2e.x, p2e.y )
		ctx.lineTo( p2e.x, p2e.y )
		ctx.lineTo( p2.x, p2.y );
		
		ctx.fill()
		ctx.stroke()
	}
	
	
	loDrawDebug( ctx, circle2,	"rgba(50,50,200,0.4)" );
	
	
	/*
	loDrawDebug( ctx, cube,		"rgba(200,200,0,0.5)" );
	loDrawDebug( ctx, rect,		"rgba(200,0,200,0.5)" );
	loDrawDebug( ctx, tri,		"rgba(0,200,200,0.5)" );
	loDrawDebug( ctx, npoly,	"rgba(0,200,200,0.5)" );
	*/
	//loDraw( ctx, circle,	"rgba(50,50,200,0.4)" );
	
	// Do console
	
	/*
	var dbgConsole = document.getElementById('loDebugConsole')
	dbgConsole.innerHTML = arr.join('<br>')
	*/
}

window.onkeydown = keydownControl;

function setup()
{
	cvs = document.getElementById("canvas");
	cvs.mouse = { x: 0, y: 0 };
	
	cvs.addEventListener
	(
		'mousemove',
		function(evt)
		{
			var mx = evt.offsetX || (evt.clientX - window.pageXOffset);
			var my = evt.offsetY || (evt.clientY - window.pageYOffset);
			
			cvs = document.getElementById("canvas");
			cvs.mouse = { x: mx, y: my };
			//draw()
		},
		false
	);

	
	var i = Math.round( Math.random() * 10 ) +1 
	while( i )
	{
		rx = Math.round( Math.random() * 600 )		// anywhere
		ry = Math.round( Math.random() * 500 )		// anywhere
		rs = Math.round( Math.random() * 25 ) + 25	// 25 to 50
		rn = Math.round( Math.random() * 8 ) + 3	// 3 to 11
		randomly.push( loPolygon.create( rx, ry, loConfine( rs ), loMakeNArray( rn ) ) )
		--i
	}
	

	draw();
}

  </script>
 </head>
 <body onload="setup()">
	loEngine v0.4<br>
	
<hr>	
   <canvas id="canvas" width="800" height="600">
	Sorry, your browser doesn't support canvas technology
   </canvas>
   <div id='loDebugConsole'></div>
   <hr>
 </body>
</html>